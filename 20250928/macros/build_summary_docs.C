#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <algorithm>
#include <cmath>
#include <string>

// Macro to build a summary report based on per-run symptom classification.
// Reads symptoms_perrun.csv generated by diagnose_runs.C and produces docs/symptom_summary.md.
void build_summary_docs() {
    std::string symptoms_file = "out/symptoms_perrun.csv";
    std::ifstream infile(symptoms_file);
    if (!infile.is_open()) {
        std::cerr << "Could not open " << symptoms_file << std::endl;
        return;
    }
    // Read header line to determine column indices
    std::string header;
    std::getline(infile, header);
    std::vector<std::string> cols;
    std::stringstream hss(header);
    std::string col;
    while (std::getline(hss, col, ',')) {
        cols.push_back(col);
    }
    int idx_run = -1;
    int idx_agg = -1;
    int idx_primary = -1;
    for (size_t i = 0; i < cols.size(); ++i) {
        if (cols[i] == "run") idx_run = i;
        else if (cols[i] == "aggregated_score") idx_agg = i;
        else if (cols[i] == "primary_cause") idx_primary = i;
    }
    std::vector<double> aggregated_scores;
    std::map<std::string,int> cause_count;
    int total_runs = 0;
    int none_count = 0;
    int mild_count = 0;
    int moderate_count = 0;
    int severe_count = 0;
    std::string line;
    // Iterate over lines and accumulate statistics
    while (std::getline(infile, line)) {
        if (line.empty()) continue;
        std::stringstream ss(line);
        std::string token;
        std::vector<std::string> tokens;
        while (std::getline(ss, token, ',')) {
            tokens.push_back(token);
        }
        if ((int)tokens.size() <= std::max({idx_run, idx_agg, idx_primary})) {
            continue;
        }
        total_runs++;
        std::string run = tokens[idx_run];
        double score = 0.0;
        try {
            score = std::stod(tokens[idx_agg]);
        } catch (...) {
            score = 0.0;
        }
        aggregated_scores.push_back(score);
        std::string cause = tokens[idx_primary];
        cause_count[cause]++;
        // Severity classification thresholds based on aggregated score
        if (score < 1.0) {
            none_count++;
        } else if (score < 2.0) {
            mild_count++;
        } else if (score < 3.0) {
            moderate_count++;
        } else {
            severe_count++;
        }
    }
    infile.close();
    // Re-read file to capture run-score pairs for ranking
    infile.open(symptoms_file);
    std::getline(infile, header);
    std::vector<std::pair<std::string,double>> run_scores;
    while (std::getline(infile, line)) {
        if (line.empty()) continue;
        std::stringstream ss(line);
        std::string token;
        std::vector<std::string> tokens;
        while (std::getline(ss, token, ',')) {
            tokens.push_back(token);
        }
        if ((int)tokens.size() <= std::max({idx_run, idx_agg, idx_primary})) {
            continue;
        }
        std::string run = tokens[idx_run];
        double score = 0.0;
        try {
            score = std::stod(tokens[idx_agg]);
        } catch (...) {
            score = 0.0;
        }
        run_scores.push_back({run, score});
    }
    infile.close();
    std::sort(run_scores.begin(), run_scores.end(), [](const auto &a, const auto &b) {
        return a.second > b.second;
    });
    // Compute mean and median aggregated scores
    double mean_score = 0.0;
    for (double s : aggregated_scores) {
        mean_score += s;
    }
    if (!aggregated_scores.empty()) {
        mean_score /= aggregated_scores.size();
    }
    double median_score = 0.0;
    if (!aggregated_scores.empty()) {
        std::vector<double> sorted = aggregated_scores;
        std::sort(sorted.begin(), sorted.end());
        size_t n = sorted.size();
        if (n % 2 == 1) {
            median_score = sorted[n / 2];
        } else {
            median_score = 0.5 * (sorted[n / 2 - 1] + sorted[n / 2]);
        }
    }
    // Create docs directory if necessary; using POSIX call
    // This macro assumes docs directory exists under 20250928
    std::ofstream out("docs/symptom_summary.md");
    out << "# Symptom Summary Report\n\n";
    out << "Generated by build_summary_docs.C macro.\n\n";
    out << "## Overview\n\n";
    out << "- Total runs analyzed: " << total_runs << "  \n";
    out << "- Mean aggregated severity score: " << mean_score << "  \n";
    out << "- Median aggregated severity score: " << median_score << "  \n\n";
    out << "### Severity Classification Counts\n\n";
    out << "- None (score < 1): " << none_count << "  \n";
    out << "- Mild (1 \u2264 score < 2): " << mild_count << "  \n";
    out << "- Moderate (2 \u2264 score < 3): " << moderate_count << "  \n";
    out << "- Severe (score \u2265 3): " << severe_count << "  \n\n";
    out << "### Primary Cause Frequency\n\n";
    for (const auto &p : cause_count) {
        out << "- " << p.first << ": " << p.second << "  \n";
    }
    out << "\n### Top Runs by Aggregated Severity\n\n";
    int topN = static_cast<int>(std::min(static_cast<size_t>(5), run_scores.size()));
    for (int i = 0; i < topN; ++i) {
        out << i + 1 << ". Run " << run_scores[i].first << " \u2014 score " << run_scores[i].second << "  \n";
    }
    out.close();
    std::cout << "Summary report generated: docs/symptom_summary.md" << std::endl;
}
